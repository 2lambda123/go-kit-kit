package server

import (
	"encoding/json"
	"io"

	"golang.org/x/net/context"
)

// Add is a function that takes two ints and returns an int.
// In this example, it's exposed as a single Endpoint.
type Add func(context.Context, int, int) int

// PureAdd is a pure implementation of the Add definition.
// It can therefore ignore the context.
func PureAdd(_ context.Context, a, b int) int { return a + b }

// AddViaResource is a non-pure implementation of the Add definition, and
// therefore must thread the Context through to the backing Resource.
func AddViaResource(r Resource) func(context.Context, int, int) int {
	return func(ctx context.Context, a, b int) int {
		return r.GetA(ctx, a) + b
	}
}

// Resource represents some arbitrary backing resource, like another service.
type Resource struct{}

// GetA represents some transform of an integer value.
func (r Resource) GetA(ctx context.Context, a int) int {
	return a
}

// AddRequest could be autogenerated from type Add.
type AddRequest struct {
	A int `json:"a"`
	B int `json:"b"`
}

// AddResponse could be autogenerated from type Add.
type AddResponse struct {
	V int `json:"v"`
}

// AddEndpoint could be autogenerated from type Add.
func AddEndpoint(a Add) Endpoint {
	return func(ctx context.Context, req Request) (Response, error) {
		addReq, ok := req.(AddRequest)
		if !ok {
			return nil, ErrBadCast
		}

		v := a(ctx, addReq.A, addReq.B)
		return AddResponse{v}, nil
	}
}

// AddCodecJSON could be autogenerated from type Add.
type AddCodecJSON struct{}

// Decode TODO
func (c *AddCodecJSON) Decode(_ context.Context, src io.Reader) (Request, error) {
	var req AddRequest
	if err := json.NewDecoder(src).Decode(&req); err != nil {
		return nil, err
	}
	return req, nil
}

// Encode TODO
func (c *AddCodecJSON) Encode(dst io.Writer, resp Response) error {
	addResp, ok := resp.(AddResponse)
	if !ok {
		return ErrBadCast
	}
	return json.NewEncoder(dst).Encode(addResp)
}
